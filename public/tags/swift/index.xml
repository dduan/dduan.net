<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Swift on dduan.net</title>
    <link>http://dduan.net/tags/swift/</link>
    <description>Recent content in Swift on dduan.net</description>
    <generator>Hugo -- gohugo.io</generator>
    
    
    
    
    <lastBuildDate>Wed, 22 Apr 2015 11:46:17 PDT</lastBuildDate>
    <atom:link href="http://dduan.net/tags/swift/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>NeoVim, Swift and Make</title>
      <link>http://dduan.net/post/2015/04/neovim-swift-and-make/</link>
      <pubDate>Wed, 22 Apr 2015 11:46:17 PDT</pubDate>
      
      <guid>http://dduan.net/post/2015/04/neovim-swift-and-make/</guid>
      <description>&lt;p&gt;When it comes to Swift source code editing, nothing beats Xcode 6.3! That
includes Xcode 6.2, which drove me to good&amp;rsquo;O Vim for a while.&lt;/p&gt;

&lt;p&gt;Except it&amp;rsquo;s not the old Vim, I&amp;rsquo;m trying out &lt;a href=&#34;http://neovim.org&#34;&gt;NeoVim&lt;/a&gt;. The
most noticable difference in NeoVim compared to Vim is its recent
addition of a built-in terminal.&lt;/p&gt;

&lt;p&gt;With the help of syntax highlighting and a Makefile, working with Swift this
way turns out to be a fine alternative.&lt;/p&gt;

&lt;p&gt;(As a side benefit, I&amp;rsquo;m forced to use only local-context autocompletion. Now
I can actually spell out full UIKit APIs ðŸ˜‰.)&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a gif:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://dduan.net/images/2015/04/demo.gif&#34; alt=&#34;Make Swift NeoVim Demo&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;Some details are easy to miss. I pressed &lt;code&gt;,m&lt;/code&gt;, &lt;code&gt;,&lt;/code&gt; being my binding for
&lt;code&gt;&amp;lt;leader&amp;gt;&lt;/code&gt;. A terminal session launched with the &lt;code&gt;make&lt;/code&gt; command running. When
that&amp;rsquo;s done, I could press any key and the terminal pane was dismissed. Since
&lt;code&gt;test&lt;/code&gt; is the default target in my &lt;code&gt;Makefile&lt;/code&gt;, the test suit for my Swift
codes actually ran.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s how the shortcut is set in &lt;code&gt;.nvimrc&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if has(&#39;nvim&#39;)
    nnoremap &amp;lt;leader&amp;gt;m :rightbelow vertical split &amp;lt;bar&amp;gt; :term make&amp;lt;cr&amp;gt;
endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The makefile is pretty straightforword if you&amp;rsquo;ve worked with &lt;code&gt;xcodebuild&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;test :
    @xcodebuild test -project ProjectName.xcodeproj -scheme SchemeName -destination &#39;platform=iOS Simulator,name=iPhone 6&#39; | xcpretty

clean :
    @xcodebuild clean
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/supermarin/xcpretty&#34;&gt;xcpretty&lt;/a&gt; is a nifty script that
makes &lt;code&gt;xcodebuild&lt;/code&gt;s output much more readable.&lt;/p&gt;

&lt;p&gt;Happy vimming, Swifties :)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Swift Function Fun Facts</title>
      <link>http://dduan.net/post/2015/04/swift-function-fun-facts/</link>
      <pubDate>Sat, 18 Apr 2015 16:20:16 PDT</pubDate>
      
      <guid>http://dduan.net/post/2015/04/swift-function-fun-facts/</guid>
      <description>&lt;p&gt;You love Swift. You want to write a class that does HTTP, it might have methods like the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func get(URLString:String, params:[String:AnyObject], headers:[String:String])
func post(URLString:String, params:[String:AnyObject], headers:[String:String])
func put(URLString:String, params:[String:AnyObject], headers:[String:String])
// and more for HEAD, OPTIONS â€¦
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But you don&amp;rsquo;t want to force your user to supply all arguments each time. You know that Swift supports default arguments, so you added some. Take GET as an example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func get(URLString:String, params:[String:AnyObject]=[:], headers:[String:String]=[:])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now users can do things like&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;get(&amp;quot;http://github.com&amp;quot;)
get(&amp;quot;http://httpbin.org/get&amp;quot;, headers:[&amp;quot;Answer&amp;quot;:42])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s flexible! Woohoo!&lt;/p&gt;

&lt;p&gt;After you thought about implementing these, though, you realize that &lt;code&gt;HTTPMethod&lt;/code&gt; is merely a property on &lt;code&gt;NSURLRequest&lt;/code&gt;. In other words, all of the previous methods can share the same implementation. In honor of the DRY principle, you write a function that accepts the method as an arguments and the previous functions each forwards the arguments to this function:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func impl(method:String, URLString:String, params:[String:AnyObject], headers:[String:String]) { // â€¦ }

func get(URLString:String, params:[String:AnyObject]=[:], headers:[String:String]=[:])
    impl(&amp;quot;GET&amp;quot;, URLString:URLString, params:params, headers:headers)
}

func post(URLString:String, params:[String:AnyObject]=[:], headers:[String:String]=[:])
    impl(&amp;quot;POST&amp;quot;, URLString:URLString, params:params, headers:headers)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This seems like a sensible solution. Except that later you realize that there needs to be more parameters for each function, so in the end, each function looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func post(
    URLString              : String,
    params                 : [String:AnyObject]       = [:],
    json                   : [String:AnyObject]?      = nil,
    headers                : [String:AnyObject]       = [:],
    auth                   : (String,String)?         = nil,
    allowRedirects         : Bool                     = true,
    requestBody            : NSData?                  = nil,
    URLQuery               : String?                  = nil,
    asyncCompletionHandler : ((HTTPResult!) -&amp;gt; Void)? = nil
    ) -&amp;gt; HTTPResult {
    return impl(
        &amp;quot;POST&amp;quot;,
        URLString              : URLString,
        params                 : params,
        json                   : json,
        headers                : headers,
        auth                   : auth,
        data                   : requestBody,
        URLQuery               : URLQuery,
        redirects              : allowRedirects,
        asyncCompletionHandler : asyncCompletionHandler
    )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Remembering that your goal is to respect DRY, and there are now giant blocks of code that all look the same except that first argument to &lt;code&gt;impl()&lt;/code&gt;, you became determined to find a better alternative.&lt;/p&gt;

&lt;p&gt;Well, why not give currying a try? This example of currying with Swift comes to your mind:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func add(a:Int)(b:Int) -&amp;gt; Int { return a + b }
let add3 = add(3)
add3(b:2) // 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we apply this technique and treat &lt;code&gt;method&lt;/code&gt; in &lt;code&gt;impl()&lt;/code&gt; as &lt;code&gt;a&lt;/code&gt; in the example, we would get:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func impl(method:String)(URLString:String, params:[String:AnyObject], headers:[String:String], â€¦) { // â€¦ }
let get = impl(&amp;quot;GET&amp;quot;)
let post = impl(&amp;quot;POST&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;right?  However, you are forcing users to supply each argument again. To make things worse, the number of arguments is a lot larger.&lt;/p&gt;

&lt;p&gt;Hmm, but that&amp;rsquo;s a solved problem, just add default values to &lt;code&gt;impl()&lt;/code&gt;&amp;rsquo;s parameters:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func impl(method:String)(URLString:String, params:[String:AnyObject] = [:], headers:[String:String] = [:], â€¦) { // â€¦ }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ta-da! Wait a minute, Xcode now refuse to compile you code! &lt;code&gt;Default argument is only permitted for a non-curried function parameter&lt;/code&gt;, it saids.&lt;/p&gt;

&lt;p&gt;Stubborn as you are, you decide that perhaps the Swift team hasn&amp;rsquo;t got around to implementing this feature for curry syntax yet. Functions are first-class citizens! Surely if you return a function with default argumentsâ€¦?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func methodFactory(method:String) -&amp;gt; (params:[String:AnyObject] = [:], headers:[String:String] = [:], â€¦) -&amp;gt; Void {
    return {(params, headers, â€¦) in
        impl(method, params:params, headers:headers, â€¦)
    }
}

let get = methodFactory(&amp;quot;GET&amp;quot;)
let post = methodFactory(&amp;quot;POST&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Turns out, this manual form of currying only works when default arguments aren&amp;rsquo;t involved!&lt;/p&gt;

&lt;p&gt;Now, you hate Swift.&lt;/p&gt;

&lt;p&gt;(Hi HN, just to be clear, I don&amp;rsquo;t really hate Swift as in, uh, &lt;em&gt;hate&lt;/em&gt; Swift. Judgning from some comments, I might have failed to convey the lightheartedness that I felt writing this up. It&amp;rsquo;s really like saying to a friend &amp;ldquo;I hate you&amp;rdquo; after he/she pulls a prank on you.)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Build And Run iOS Apps In Commmand Line</title>
      <link>http://dduan.net/post/2015/02/build-and-run-ios-apps-in-commmand-line/</link>
      <pubDate>Sat, 07 Feb 2015 20:35:02 PST</pubDate>
      
      <guid>http://dduan.net/post/2015/02/build-and-run-ios-apps-in-commmand-line/</guid>
      <description>&lt;p&gt;Xcode is slow. Enough said. What&amp;rsquo;s worse, sometimes I find myself
relying too much on auto-completion with Cocoa Touch, a blessing and a curse!&lt;/p&gt;

&lt;p&gt;So I searched for an alternative workflow in command line. The result was
rather confusing: there are posts about using &lt;code&gt;xctool&lt;/code&gt; or &lt;code&gt;xcodebuild&lt;/code&gt; to
build Xcode targets, using &lt;code&gt;ios-sim&lt;/code&gt;, &lt;code&gt;simctl&lt;/code&gt;  or &lt;code&gt;instruments&lt;/code&gt; to manage and
manage or launch simulators. Most of the information is out of date.&lt;/p&gt;

&lt;p&gt;Eventually though, I was able to piece together an answer for my needs.
That is, given an iOS project set up with Xcode 6, I want to&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;build a target.&lt;/li&gt;
&lt;li&gt;launch a iOS simulator.&lt;/li&gt;
&lt;li&gt;install the built .app bundle to the launched simulator.&lt;/li&gt;
&lt;li&gt;run the installed app.&lt;/li&gt;
&lt;li&gt;uninstall the app from the simulator.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;All in command line, with Xcode &lt;em&gt;closed&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Before we proceed to the steps, you need to gather a few pieces of information:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;the Xcode build scheme of your choice (e.g. &amp;ldquo;AwesomeApp&amp;rdquo;).&lt;/li&gt;
&lt;li&gt;your app bundle ID (e.g. &amp;ldquo;com.awesome.app&amp;rdquo;).&lt;/li&gt;
&lt;li&gt;name of an existing simulator (e.g. &amp;ldquo;iPhone 6 Plus&amp;rdquo;). If you don&amp;rsquo;t want to
look it up in Xcode GUI, look for it in output of command &lt;code&gt;xcrun simctl
list&lt;/code&gt; .&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Ready? Here we go.&lt;/p&gt;

&lt;p&gt;(These commands should be run in the project folder).&lt;/p&gt;

&lt;p&gt;Build the target:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xcodebuild -scheme AwesomeApp -destination &#39;platform=iphonesimulator,name=iPhone 6 Plus&#39; -derivedDataPath build
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Launch the simulator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xcrun instruments -w &#39;iPhone 6 Plus&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Install the bundle (after simulator is launched and target is built with
previous commands):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xcrun simctl install booted build/Build/Products/Debug-iphonesimulator/AwesomeApp.app
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Launch the app in simulator (after it&amp;rsquo;s installed with the previous command):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xcrun simctl launch booted com.awesome.app
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Uninstall the bundle:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xcrun simctl uninstall booted com.awesome.app
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Quite a few parameters needs to be added for the build step if you have
a comlex project. Please RTFMs. Write some script to automate the steps, if
are a lazy typiest like me.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>