<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Swift on dduan.net</title>
    <link>http://dduan.net/tags/swift/</link>
    <description>Recent content in Swift on dduan.net</description>
    <generator>Hugo -- gohugo.io</generator>
    
    
    
    
    <lastBuildDate>Sun, 05 Jul 2015 22:36:09 PDT</lastBuildDate>
    <atom:link href="http://dduan.net/tags/swift/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Dynamic Swift Framework Without Xcode</title>
      <link>http://dduan.net/post/2015/07/dynamic-swift-framework-without-xcode/</link>
      <pubDate>Sun, 05 Jul 2015 22:36:09 PDT</pubDate>
      
      <guid>http://dduan.net/post/2015/07/dynamic-swift-framework-without-xcode/</guid>
      <description>&lt;p&gt;I came up with this question recently:&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;en&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;Can we even use Frameworks with &lt;a href=&#34;https://twitter.com/hashtag/Swiftlang?src=hash&#34;&gt;#Swiftlang&lt;/a&gt; on Linux?&lt;/p&gt;&amp;mdash; Daniel Duan (@daniel_duan) &lt;a href=&#34;https://twitter.com/daniel_duan/status/617470929241706496&#34;&gt;July 4, 2015&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;And I&amp;rsquo;m going to give the answer in this post (spoiler alert: yes, sort of).&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the content of a framework created by Xcode:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;images/2015/07/just-framework-structure.png&#34; alt=&#34;Just Framework Structure&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;Some of the files, such as &lt;code&gt;Info.plist&lt;/code&gt;, are obviously construct of Xcode.
Play with &lt;code&gt;swiftc&lt;/code&gt; long enough, one would find that the &lt;code&gt;.swiftdoc&lt;/code&gt;s, the
&lt;code&gt;.swiftmodule&lt;/code&gt;s and the one binary file came from the Swift compiler.&lt;/p&gt;

&lt;p&gt;Instead of listing the relevant &lt;code&gt;swiftc&lt;/code&gt; command options, I&amp;rsquo;ve created a &lt;a href=&#34;https://github.com/dduan/Swift-Framework-Without-Xcode&#34;&gt;sample project&lt;/a&gt; to demonstrate how one can complie and link to frameworks so that they can be &lt;code&gt;import&lt;/code&gt;ed in the application code. The key ingredient for achieving it lies in &lt;em&gt;Makefile&lt;/em&gt;. In summary, &lt;code&gt;swiftc&lt;/code&gt; can do these for us:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;generate a binary as a library/framework&lt;/li&gt;
&lt;li&gt;emit a &lt;code&gt;.swiftmodule&lt;/code&gt; file, which Swift needs to understand that binary.&lt;/li&gt;
&lt;li&gt;assign a path the Swift runtime needs to locate this framework.&lt;/li&gt;
&lt;li&gt;compile source code that imports the framework, given that they exist in the paths relative to the app binary in step 3.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Based on these observations, it&amp;rsquo;s not hard to imagine more sophisticated build systems, such as IDEs and package/dependency management systems.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Let&#39;s Build A &#39;cat&#39; In Swift 2</title>
      <link>http://dduan.net/post/2015/07/lets-build-a-cat-in-swift-2/</link>
      <pubDate>Sat, 04 Jul 2015 20:56:19 PDT</pubDate>
      
      <guid>http://dduan.net/post/2015/07/lets-build-a-cat-in-swift-2/</guid>
      <description>&lt;p&gt;As a homework in one of the early college classes, I was asked to write unix
commands such as &lt;code&gt;cat&lt;/code&gt; in C. Let&amp;rsquo;s do that in Swift today! To make things
interesting, let&amp;rsquo;s pretend we are on Linux. That means no Xcode nor Foundation
can be used.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s hard to find a simpler unix program than &lt;code&gt;cat&lt;/code&gt;: It takes a list of file
names from the shell and write the content of each file to &lt;code&gt;stdout&lt;/code&gt;. When no
argument is given, it uses &lt;code&gt;stdin&lt;/code&gt; as the source of its output.&lt;/p&gt;

&lt;p&gt;Writing it in C is trivial. Swift has exellent support for leveraging C. But
to call even the standard C functions, we need to import them first.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;swiftc&lt;/code&gt; command can compile a pure Swift source file like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;swiftc cat.swift -o cat
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can add Objective-C bridging headers with the argument
&lt;code&gt;-import-objc-header&lt;/code&gt;.  But to import the standard C functions, we also need
to specify path to an SDK:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;swiftc -sdk $(xcrun --show-sdk-path --sdk macosx)\
       -import-objc-header bridge.h\
       cat.swift\
       -o cat
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Instead of typing/copying that command, save this &lt;code&gt;Makefile&lt;/code&gt; to the same
directory as &lt;code&gt;cat.swift&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SDKPATH = $(shell xcrun --show-sdk-path --sdk macosx)
CBRIDGEHEADER = bridge.h
TARGETS := cat

.PHONY : all $(TARGETS)

all: $(TARGETS)

$(TARGETS):
    swiftc -sdk $(SDKPATH) $@.swift -import-objc-header $(CBRIDGEHEADER) -o $@
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now &lt;code&gt;make cat&lt;/code&gt; should take care of the compilation.&lt;/p&gt;

&lt;p&gt;Since file I/O is the only concern, we&amp;rsquo;ll need C APIs from &lt;code&gt;stdio.h&lt;/code&gt;, so
&lt;code&gt;bridge.h&lt;/code&gt; is a one liner:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#import &amp;lt;stdio.h&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The standard C function for opening a file is &lt;code&gt;fopen&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FILE * fopen ( const char *filename, const char *mode );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hmmmm, how do we deal with all those pesky &amp;lsquo;*&amp;rsquo;s?&lt;/p&gt;

&lt;p&gt;To reference a certain C &lt;code&gt;Type&lt;/code&gt; in Swift, we can use &lt;code&gt;UnsafePointer&amp;lt;Type&amp;gt;&lt;/code&gt; or
&lt;code&gt;UnsafeMutablePointer&amp;lt;Type&amp;gt;&lt;/code&gt;. To make our lives easier, Swift &lt;code&gt;String&lt;/code&gt;s
automatically bridge to &lt;code&gt;const char *&lt;/code&gt;. In other words, we can treat the
signature of &lt;code&gt;fopen&lt;/code&gt; as if it&amp;rsquo;s the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func fopen( filename: String, mode: String ) -&amp;gt; UnsafeMutablePointer&amp;lt;FILE&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A character in C is represented by a byte in memory. Therefore Swift sees
a &lt;code&gt;char&lt;/code&gt; as of type &lt;code&gt;Int8&lt;/code&gt; (8-bit integer).  So a &lt;code&gt;char *&lt;/code&gt; would be referenced
as &lt;code&gt;UnsafeMutablePointer&amp;lt;Int8&amp;gt;&lt;/code&gt; in Swift. So &lt;code&gt;getline&lt;/code&gt;, a function from POSIX&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssize_t getline( char **lineptr, size_t *n, FILE *stream );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;would look like this in Swift:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func getline(
    inout lineptr: UnsafeMutablePointer&amp;lt;Int8&amp;gt;,
    inout n: UInt,
    stream: UnsafeMutablePointer&amp;lt;FILE&amp;gt;
) -&amp;gt; Int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It returns the number if characters it finds.&lt;/p&gt;

&lt;p&gt;We now can open a file, read and print its content line by line, and close it
with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func fclose(stream: UnsafeMutablePointer&amp;lt;FILE&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Repeat this on each file specified in &lt;code&gt;Process.arguments&lt;/code&gt;, or simply read from
&lt;code&gt;stdin&lt;/code&gt;, and we have a &lt;code&gt;cat&lt;/code&gt;! Here&amp;rsquo;s a screenshot of it displaying its own
code:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/2015/07/swift-cat.png&#34; alt=&#34;Swift cat&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;The code is also available in this &lt;a href=&#34;https://gist.github.com/dduan/f6d359019db8b0b55962&#34;&gt;gist&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>NeoVim, Swift and Make</title>
      <link>http://dduan.net/post/2015/04/neovim-swift-and-make/</link>
      <pubDate>Wed, 22 Apr 2015 11:46:17 PDT</pubDate>
      
      <guid>http://dduan.net/post/2015/04/neovim-swift-and-make/</guid>
      <description>&lt;p&gt;When it comes to Swift source code editing, nothing beats Xcode 6.3! That
includes Xcode 6.2, which drove me to good&amp;rsquo;O Vim for a while.&lt;/p&gt;

&lt;p&gt;Except it&amp;rsquo;s not the old Vim, I&amp;rsquo;m trying out &lt;a href=&#34;http://neovim.org&#34;&gt;NeoVim&lt;/a&gt;. The
most noticable difference in NeoVim compared to Vim is its recent
addition of a built-in terminal.&lt;/p&gt;

&lt;p&gt;With the help of syntax highlighting and a Makefile, working with Swift this
way turns out to be a fine alternative.&lt;/p&gt;

&lt;p&gt;(As a side benefit, I&amp;rsquo;m forced to use only local-context autocompletion. Now
I can actually spell out full UIKit APIs ðŸ˜‰.)&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a gif:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/2015/04/demo.gif&#34; alt=&#34;Make Swift NeoVim Demo&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;Some details are easy to miss. I pressed &lt;code&gt;,m&lt;/code&gt;, &lt;code&gt;,&lt;/code&gt; being my binding for
&lt;code&gt;&amp;lt;leader&amp;gt;&lt;/code&gt;. A terminal session launched with the &lt;code&gt;make&lt;/code&gt; command running. When
that&amp;rsquo;s done, I could press any key and the terminal pane was dismissed. Since
&lt;code&gt;test&lt;/code&gt; is the default target in my &lt;code&gt;Makefile&lt;/code&gt;, the test suit for my Swift
codes actually ran.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s how the shortcut is set in &lt;code&gt;.nvimrc&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if has(&#39;nvim&#39;)
    nnoremap &amp;lt;leader&amp;gt;m :rightbelow vertical split &amp;lt;bar&amp;gt; :term make&amp;lt;cr&amp;gt;
endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The makefile is pretty straightforword if you&amp;rsquo;ve worked with &lt;code&gt;xcodebuild&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;test :
    @xcodebuild test -project ProjectName.xcodeproj -scheme SchemeName -destination &#39;platform=iOS Simulator,name=iPhone 6&#39; | xcpretty

clean :
    @xcodebuild clean
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/supermarin/xcpretty&#34;&gt;xcpretty&lt;/a&gt; is a nifty script that
makes &lt;code&gt;xcodebuild&lt;/code&gt;s output much more readable.&lt;/p&gt;

&lt;p&gt;Happy vimming, Swifties :)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Swift Function Fun Facts</title>
      <link>http://dduan.net/post/2015/04/swift-function-fun-facts/</link>
      <pubDate>Sat, 18 Apr 2015 16:20:16 PDT</pubDate>
      
      <guid>http://dduan.net/post/2015/04/swift-function-fun-facts/</guid>
      <description>&lt;p&gt;You love Swift. You want to write a class that does HTTP, it might have methods like the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func get(URLString:String, params:[String:AnyObject], headers:[String:String])
func post(URLString:String, params:[String:AnyObject], headers:[String:String])
func put(URLString:String, params:[String:AnyObject], headers:[String:String])
// and more for HEAD, OPTIONS â€¦
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But you don&amp;rsquo;t want to force your user to supply all arguments each time. You know that Swift supports default arguments, so you added some. Take GET as an example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func get(URLString:String, params:[String:AnyObject]=[:], headers:[String:String]=[:])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now users can do things like&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;get(&amp;quot;http://github.com&amp;quot;)
get(&amp;quot;http://httpbin.org/get&amp;quot;, headers:[&amp;quot;Answer&amp;quot;:42])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s flexible! Woohoo!&lt;/p&gt;

&lt;p&gt;After you thought about implementing these, though, you realize that &lt;code&gt;HTTPMethod&lt;/code&gt; is merely a property on &lt;code&gt;NSURLRequest&lt;/code&gt;. In other words, all of the previous methods can share the same implementation. In honor of the DRY principle, you write a function that accepts the method as an arguments and the previous functions each forwards the arguments to this function:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func impl(method:String, URLString:String, params:[String:AnyObject], headers:[String:String]) { // â€¦ }

func get(URLString:String, params:[String:AnyObject]=[:], headers:[String:String]=[:])
    impl(&amp;quot;GET&amp;quot;, URLString:URLString, params:params, headers:headers)
}

func post(URLString:String, params:[String:AnyObject]=[:], headers:[String:String]=[:])
    impl(&amp;quot;POST&amp;quot;, URLString:URLString, params:params, headers:headers)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This seems like a sensible solution. Except that later you realize that there needs to be more parameters for each function, so in the end, each function looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func post(
    URLString              : String,
    params                 : [String:AnyObject]       = [:],
    json                   : [String:AnyObject]?      = nil,
    headers                : [String:AnyObject]       = [:],
    auth                   : (String,String)?         = nil,
    allowRedirects         : Bool                     = true,
    requestBody            : NSData?                  = nil,
    URLQuery               : String?                  = nil,
    asyncCompletionHandler : ((HTTPResult!) -&amp;gt; Void)? = nil
    ) -&amp;gt; HTTPResult {
    return impl(
        &amp;quot;POST&amp;quot;,
        URLString              : URLString,
        params                 : params,
        json                   : json,
        headers                : headers,
        auth                   : auth,
        data                   : requestBody,
        URLQuery               : URLQuery,
        redirects              : allowRedirects,
        asyncCompletionHandler : asyncCompletionHandler
    )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Remembering that your goal is to respect DRY, and there are now giant blocks of code that all look the same except that first argument to &lt;code&gt;impl()&lt;/code&gt;, you became determined to find a better alternative.&lt;/p&gt;

&lt;p&gt;Well, why not give currying a try? This example of currying with Swift comes to your mind:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func add(a:Int)(b:Int) -&amp;gt; Int { return a + b }
let add3 = add(3)
add3(b:2) // 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we apply this technique and treat &lt;code&gt;method&lt;/code&gt; in &lt;code&gt;impl()&lt;/code&gt; as &lt;code&gt;a&lt;/code&gt; in the example, we would get:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func impl(method:String)(URLString:String, params:[String:AnyObject], headers:[String:String], â€¦) { // â€¦ }
let get = impl(&amp;quot;GET&amp;quot;)
let post = impl(&amp;quot;POST&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;right?  However, you are forcing users to supply each argument again. To make things worse, the number of arguments is a lot larger.&lt;/p&gt;

&lt;p&gt;Hmm, but that&amp;rsquo;s a solved problem, just add default values to &lt;code&gt;impl()&lt;/code&gt;&amp;rsquo;s parameters:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func impl(method:String)(URLString:String, params:[String:AnyObject] = [:], headers:[String:String] = [:], â€¦) { // â€¦ }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ta-da! Wait a minute, Xcode now refuse to compile you code! &lt;code&gt;Default argument is only permitted for a non-curried function parameter&lt;/code&gt;, it saids.&lt;/p&gt;

&lt;p&gt;Stubborn as you are, you decide that perhaps the Swift team hasn&amp;rsquo;t got around to implementing this feature for curry syntax yet. Functions are first-class citizens! Surely if you return a function with default argumentsâ€¦?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func methodFactory(method:String) -&amp;gt; (params:[String:AnyObject] = [:], headers:[String:String] = [:], â€¦) -&amp;gt; Void {
    return {(params, headers, â€¦) in
        impl(method, params:params, headers:headers, â€¦)
    }
}

let get = methodFactory(&amp;quot;GET&amp;quot;)
let post = methodFactory(&amp;quot;POST&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Turns out, this manual form of currying only works when default arguments aren&amp;rsquo;t involved!&lt;/p&gt;

&lt;p&gt;Now, you hate Swift.&lt;/p&gt;

&lt;p&gt;(Hi HN, just to be clear, I don&amp;rsquo;t really hate Swift as in, uh, &lt;em&gt;hate&lt;/em&gt; Swift. Judgning from some comments, I might have failed to convey the lightheartedness that I felt writing this up. It&amp;rsquo;s really like saying to a friend &amp;ldquo;I hate you&amp;rdquo; after he/she pulls a prank on you.)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Build And Run iOS Apps In Commmand Line</title>
      <link>http://dduan.net/post/2015/02/build-and-run-ios-apps-in-commmand-line/</link>
      <pubDate>Sat, 07 Feb 2015 20:35:02 PST</pubDate>
      
      <guid>http://dduan.net/post/2015/02/build-and-run-ios-apps-in-commmand-line/</guid>
      <description>&lt;p&gt;Xcode is slow. Enough said. What&amp;rsquo;s worse, sometimes I find myself
relying too much on auto-completion with Cocoa Touch, a blessing and a curse!&lt;/p&gt;

&lt;p&gt;So I searched for an alternative workflow in command line. The result was
rather confusing: there are posts about using &lt;code&gt;xctool&lt;/code&gt; or &lt;code&gt;xcodebuild&lt;/code&gt; to
build Xcode targets, using &lt;code&gt;ios-sim&lt;/code&gt;, &lt;code&gt;simctl&lt;/code&gt;  or &lt;code&gt;instruments&lt;/code&gt; to manage and
manage or launch simulators. Most of the information is out of date.&lt;/p&gt;

&lt;p&gt;Eventually though, I was able to piece together an answer for my needs.
That is, given an iOS project set up with Xcode 6, I want to&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;build a target.&lt;/li&gt;
&lt;li&gt;launch a iOS simulator.&lt;/li&gt;
&lt;li&gt;install the built .app bundle to the launched simulator.&lt;/li&gt;
&lt;li&gt;run the installed app.&lt;/li&gt;
&lt;li&gt;uninstall the app from the simulator.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;All in command line, with Xcode &lt;em&gt;closed&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Before we proceed to the steps, you need to gather a few pieces of information:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;the Xcode build scheme of your choice (e.g. &amp;ldquo;AwesomeApp&amp;rdquo;).&lt;/li&gt;
&lt;li&gt;your app bundle ID (e.g. &amp;ldquo;com.awesome.app&amp;rdquo;).&lt;/li&gt;
&lt;li&gt;name of an existing simulator (e.g. &amp;ldquo;iPhone 6 Plus&amp;rdquo;). If you don&amp;rsquo;t want to
look it up in Xcode GUI, look for it in output of command &lt;code&gt;xcrun simctl
list&lt;/code&gt; .&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Ready? Here we go.&lt;/p&gt;

&lt;p&gt;(These commands should be run in the project folder).&lt;/p&gt;

&lt;p&gt;Build the target:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xcodebuild -scheme AwesomeApp -destination &#39;platform=iphonesimulator,name=iPhone 6 Plus&#39; -derivedDataPath build
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Launch the simulator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xcrun instruments -w &#39;iPhone 6 Plus&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Install the bundle (after simulator is launched and target is built with
previous commands):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xcrun simctl install booted build/Build/Products/Debug-iphonesimulator/AwesomeApp.app
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Launch the app in simulator (after it&amp;rsquo;s installed with the previous command):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xcrun simctl launch booted com.awesome.app
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Uninstall the bundle:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xcrun simctl uninstall booted com.awesome.app
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Quite a few parameters needs to be added for the build step if you have
a comlex project. Please RTFMs. Write some script to automate the steps, if
are a lazy typiest like me.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>