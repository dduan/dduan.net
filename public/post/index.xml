<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on dduan.net</title>
    <link>http://dduan.net/post/</link>
    <description>Recent content in Posts on dduan.net</description>
    <generator>Hugo -- gohugo.io</generator>
    
    
    
    
    <lastBuildDate>Sun, 01 Nov 2015 11:18:40 PST</lastBuildDate>
    <atom:link href="http://dduan.net/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>char ** in Swift</title>
      <link>http://dduan.net/post/2015/11/char-star-star-in-swift/</link>
      <pubDate>Sun, 01 Nov 2015 11:18:40 PST</pubDate>
      
      <guid>http://dduan.net/post/2015/11/char-star-star-in-swift/</guid>
      <description>&lt;p&gt;A &amp;ldquo;string&amp;rdquo; in C is just a continuous chunk of &lt;code&gt;char&lt;/code&gt; values in memory with
&lt;code&gt;\0&lt;/code&gt; at the end. To reference it, a variable of type &lt;code&gt;char *&lt;/code&gt; is used to store
the address of the first &lt;code&gt;char&lt;/code&gt; (commonly known as a pointer ðŸ˜‰).  It&amp;rsquo;s common
to have string manipulating functions take this form:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void foo(char **errorMessage) { // ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To mutate the arugment &lt;code&gt;errorMessage&lt;/code&gt; of type &lt;code&gt;char *&lt;/code&gt;, &lt;code&gt;foo&lt;/code&gt; takes a pointer
to it, &lt;code&gt;(char *)*&lt;/code&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;How do we call &lt;code&gt;foo&lt;/code&gt; in Swift?&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the tl;dr. We can wrap it in a Swift function that have the same
interface:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func fooSwift(inout errorMessage: String?) {
    var message: UnsafeMutablePointer&amp;lt;CChar&amp;gt; = nil

    foo(&amp;amp;message)
    errorMessage = String.fromCString(message)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;errorMessage&lt;/code&gt; will contain whatever our C function &lt;code&gt;foo&lt;/code&gt; assigns to it.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;So, what&amp;rsquo;s really going on here?&lt;/p&gt;

&lt;p&gt;Inspecting &lt;code&gt;foo&lt;/code&gt;&amp;rsquo;s signature in Swift, we see&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func foo(errorMessage: UnsafeMutablePointer&amp;lt;UnsafeMutablePointer&amp;lt;CChar&amp;gt;&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;â€¦ okey, &lt;code&gt;errorMessage&lt;/code&gt;&amp;rsquo;s type is little intimidating to someone who doesn&amp;rsquo;t
use C functions in Swift everyday (like me)!&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s break it down. Swift does a ton of work for us to interoperate with C:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;CChar&lt;/code&gt; is Swift&amp;rsquo;s name for &lt;em&gt;&lt;code&gt;char&lt;/code&gt; in C&lt;/em&gt; (shocking, amiright?)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;UnsafeMutablePointer&amp;lt;Type&amp;gt;&lt;/code&gt; roughly translates to &lt;code&gt;Type *&lt;/code&gt;, so
syntactically, we can see why
&lt;code&gt;UnsafeMutablePointer&amp;lt;UnsafeMutablePointer&amp;lt;CChar&amp;gt;&amp;gt;&lt;/code&gt; is used to bridge the
C type &lt;code&gt;(char *)*&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A function that takes &lt;code&gt;UnsafeMutablePointer&amp;lt;Type&amp;gt;&lt;/code&gt; argument accepts
&lt;code&gt;inout Type&lt;/code&gt; values. Therefore, we can look at &lt;code&gt;foo&lt;/code&gt; as&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foo(inout errorMessage: UnsafeMutablePointer&amp;lt;CChar&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Swift acknowledge C&amp;rsquo;s string representation and provides convenient
methods for converting &lt;code&gt;char *&lt;/code&gt; / &lt;code&gt;UnsafeMutablePointer&amp;lt;CChar&amp;gt;&lt;/code&gt; to its own
&lt;code&gt;String&lt;/code&gt; type (&lt;code&gt;String.fromCString()&lt;/code&gt;).&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Hopefully you can see how &lt;code&gt;fooSwift&lt;/code&gt; works now.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Taking a step back, to deal with &lt;code&gt;char **&lt;/code&gt; in Swift, we overcame 2 obstacles:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The difference in string representation between C and Swift.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Compared to C pointers, Swift&amp;rsquo;s &lt;code&gt;inout&lt;/code&gt; expresses mutability of function
arguments in a more restricted way. We can&amp;rsquo;t nest &lt;code&gt;inout&lt;/code&gt;s to represent
the infinite layers of indirections that pointers achieve.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Let&#39;s Play LLVM in Swift: Setup</title>
      <link>http://dduan.net/post/2015/10/lets-play-llvm-in-swift-setup/</link>
      <pubDate>Sun, 25 Oct 2015 11:53:15 PDT</pubDate>
      
      <guid>http://dduan.net/post/2015/10/lets-play-llvm-in-swift-setup/</guid>
      <description>

&lt;p&gt;&lt;em&gt;The prospect of Swift being open-source excites me. In preparation for it, I
decided to learn a little bit about LLVM. In the offical &lt;a href=&#34;http://llvm.org/docs/tutorial/index.html&#34;&gt;tutorial&lt;/a&gt;, C++
and OCaml are used to create a programming language. So I asked myself: why not
Swift? As you&amp;rsquo;ll see in this post, Swift is as good as any language when it
comes to leveraging LLVM.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;LLVM is an &amp;ldquo;compiler infrastructure&amp;rdquo;. As a user, that translates to &amp;ldquo;a set of
libraries to help us create programming language and tools&amp;rdquo;. Since this is
not an introduction to the LLVM project, it suffices to say that LLVM makes
creating programming language easy: give your language in &lt;a href=&#34;http://llvm.org/docs/LangRef.html&#34;&gt;LLVM IR&lt;/a&gt; form
and you get the rest of a native/JIT language for free, optimization included!&lt;/p&gt;

&lt;p&gt;LLVM&amp;rsquo;s default API is in C++. In addition, it officially offers a C wrapper.
Lucky for us, Swift is C-interoperable â€“ no bridging necessary :)&lt;/p&gt;

&lt;p&gt;Now we arrive at our goal for this post: create an Xcode project that can make
calls into LLVM&amp;rsquo;s C API, aka to compile this single line of code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let module = LLVMModuleCreateWithName(&amp;quot;my_module&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I assume you have Xcode 7.1 installed on OS X 10.11, but no more.&lt;/p&gt;

&lt;h2 id=&#34;1-getting-llvm:59bf6fe233ce6d0b61b7817ce0d2f9aa&#34;&gt;1. Getting LLVM&lt;/h2&gt;

&lt;p&gt;There are a lot of materials on the internet dedicated to setting up an LLVM
environment. As we are not working &lt;em&gt;on&lt;/em&gt; LLVM itself, and we are not on some
crazy custom Linux environment (to be fair, it&amp;rsquo;s trivial to set LLVM up on
most major Linux distributions), the &lt;a href=&#34;http://llvm.org/releases/download.html&#34;&gt;pre-built Clang binaries&lt;/a&gt; is good
enough. Download and unpack the .tar file somewhere handy in on your hard
drive. For example, I put it at &lt;code&gt;$(HOME)/usr/local/clang-3.4&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Aaaand we&amp;rsquo;re done. We have LLVM.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Sidenote: Xcode installs clang the compiler, but a lot of LLVM tools are
missing. That&amp;rsquo;s why we need a separate LLVM/Clang setup.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;2-create-an-xcode-project:59bf6fe233ce6d0b61b7817ce0d2f9aa&#34;&gt;2. Create an Xcode Project&lt;/h2&gt;

&lt;p&gt;Create a new OS X - Command Line Tool Xcode project, choose Swift as it&amp;rsquo;s
language.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/2015/10/llvm-swift-01-create-cmd-project.png&#34; alt=&#34;Create A Command Line Xcode Project For LLVM&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;Accessing C stuff in Swift is the same as using your Objective-C
classes. So we need to &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html&#34;&gt;create a bridging header&lt;/a&gt;. (I usually create
a Objective-C class so that Xcode prompts me for creating the header, then I
delete the .h and .m files). The project layout is now:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/2015/10/llvm-swift-02-bridging-header.png&#34; alt=&#34;Create a bridging header to import LLVM C libraries&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;Import the LLVM headers for its C interface. For our example, this is the
entire bridging header:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#import &amp;lt;llvm-c/Core.h&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s probably a good time to replace content of &lt;code&gt;main.swift&lt;/code&gt; with our awesome
LLVM IR-generating code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let module = LLVMModuleCreateWithName(&amp;quot;my_module&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-teach-xcode-about-llvm:59bf6fe233ce6d0b61b7817ce0d2f9aa&#34;&gt;3. Teach Xcode About LLVM&lt;/h2&gt;

&lt;p&gt;Our code would not compile at this point. Xcode complains that the LLVM header
can not be found. Before you jump to the target build settings, allow me
introduce &lt;code&gt;llvm-config&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;It turns out that the compliler flags for building a compiler can get complex
pretty quickly. So LLVM comes with a command that generates them. For me it
lives under &lt;code&gt;$(HOME)/usr/local/clang-3.4/bin&lt;/code&gt;. We can ask it for flags that
compiles standard C++, links standard and core libraries like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;llvm-config --cxxflags --ldflags --system-libs --libs core
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(As we use more and more LLVM libraries in the future, the list following
&lt;code&gt;--libs&lt;/code&gt; will grow. &lt;code&gt;core&lt;/code&gt; is all we need to compile our example). To anyone
who&amp;rsquo;s used GCC/Clang in command line, the output should be pretty
self-explanatory:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-I/Users/drchrono/local/clang-3.4/include  -DNDEBUG -D_GNU_SOURCE -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -O3  -std=c++11 -fvisibility-inlines-hidden -fno-exceptions -fno-rtti -fno-common -Wcast-qual
-L/Users/drchrono/local/clang-3.4/lib 
-lLLVMCore -lLLVMSupport
-lz -lpthread -ledit -lcurses -lm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;rsquo;ll walk through how to ask Xcode to respect these.&lt;/p&gt;

&lt;p&gt;First, go to build settings and set search paths for header files and
libraries according to output from &lt;code&gt;llvm-config&lt;/code&gt;. For me that means:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/2015/10/llvm-swift-03-header-search-path.png&#34; alt=&#34;Set LLVM header search path in Xcode&#34; /&gt;

&lt;img src=&#34;/images/2015/10/llvm-swift-04-library-search-path.png&#34; alt=&#34;Set LLVM library search path in Xcode&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;If you try to compile, now Xcode tells you some #define is missing. Again,
we can find them in &lt;code&gt;llvm-config&lt;/code&gt;&amp;rsquo;s result. Navigate to &amp;ldquo;Preprocessing&amp;rdquo; in
build setting and add those values starting with &lt;code&gt;-D&lt;/code&gt;, with out the &lt;code&gt;-D&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/2015/10/llvm-swift-05-macros.png&#34; alt=&#34;Set preprocessor macros&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;Remember to add these for both &amp;ldquo;Debug&amp;rdquo; and &amp;ldquo;Release&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;The last step is asking Xcode to link againt the LLVM libraries. Paste in the
&lt;code&gt;-l&lt;/code&gt; flags from &lt;code&gt;llvm-config&lt;/code&gt; at &amp;ldquo;Other Linker Flags&amp;rdquo;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/2015/10/llvm-swift-06-link-libraries.png&#34; alt=&#34;Ask Xcode to link against LLVM libraries&#34; /&gt;
&lt;/p&gt;

&lt;h2 id=&#34;4-conclusion:59bf6fe233ce6d0b61b7817ce0d2f9aa&#34;&gt;4. Conclusion&lt;/h2&gt;

&lt;p&gt;Now our Swift LLVM code compiles! Looking back, setting LLVM up with Xcode is
no more special than setting up with any C libraries. Hopefully this post will
cut down research time for some. Now go create awesome natively languages in
Swift!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Swift Algebraic Data Types</title>
      <link>http://dduan.net/post/2015/07/swift-algebraic-data-types/</link>
      <pubDate>Sun, 12 Jul 2015 15:51:27 PDT</pubDate>
      
      <guid>http://dduan.net/post/2015/07/swift-algebraic-data-types/</guid>
      <description>

&lt;h2 id=&#34;the-basics:4f5e1fa087d5cae149dabfbcf54f13c6&#34;&gt;The Basics&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Algebraic_data_type&#34;&gt;Algebraic Data Type&lt;/a&gt; is a fancy name for &amp;ldquo;a type creaded by combining other
types&amp;rdquo; in programming languages. One aspect of the &amp;ldquo;algebraic-ness&amp;rdquo; is how
many potential new values there are for the new type, given a set of type as
its building block.&lt;/p&gt;

&lt;p&gt;To better illustrate this, consider the following example in Swift.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;enum StarkChild { case Rickon, Bran, Arya, Sansa, Robb, Jon }

enum Direwolf { case Shaggydog, Summer, Nymeria, Lady, Greywind, Ghost }

enum Actor {
    case Wolf(Direwolf)
    case Person(StarkChild)
}

struct Parters {
    var wolf: Direwolf
    var person: StarkChild
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;StarkChild&lt;/code&gt; and &lt;code&gt;Direwolf&lt;/code&gt; each has 6 potential values. Combining them, we
get two new types.&lt;/p&gt;

&lt;p&gt;Question: how many potentiol values are there for &lt;code&gt;Actor&lt;/code&gt;? How many for
&lt;code&gt;Parters&lt;/code&gt;?&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;An &lt;code&gt;Actor&lt;/code&gt; can be either a &lt;code&gt;StarkChild&lt;/code&gt; or a &lt;code&gt;DireWolf&lt;/code&gt;, therefore it has &lt;code&gt;6
+ 6 = 12&lt;/code&gt; potential values â€“ the &lt;em&gt;sum&lt;/em&gt; of &lt;code&gt;Child&lt;/code&gt;&amp;rsquo;s and &lt;code&gt;DireWolf&lt;/code&gt;&amp;rsquo;s values.&lt;/p&gt;

&lt;p&gt;A &lt;code&gt;Partners&lt;/code&gt; requires us to select one value from &lt;code&gt;Child&lt;/code&gt; and one from
&lt;code&gt;DireWolf&lt;/code&gt;, resulting in &lt;code&gt;6 * 6 = 36&lt;/code&gt; potential values â€“ the &lt;em&gt;product&lt;/em&gt; of
&lt;code&gt;Child&lt;/code&gt;&amp;rsquo;s and &lt;code&gt;DireWolf&lt;/code&gt;&amp;rsquo;s values.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Actor&lt;/code&gt;, an &lt;code&gt;enum&lt;/code&gt;, is a &lt;em&gt;sum&lt;/em&gt; type. &lt;code&gt;Parters&lt;/code&gt;, a &lt;code&gt;struct&lt;/code&gt;, is a &lt;em&gt;product&lt;/em&gt;
type. Here, &lt;code&gt;Parters&lt;/code&gt; could easily be defined as a &lt;code&gt;class&lt;/code&gt; or a &lt;code&gt;tuple&lt;/code&gt; and
remain a &lt;em&gt;product&lt;/em&gt; type. Because we can create product or sum types in these
direct ways, we can say Swift has first class support for Algebraic Data
Types.&lt;/p&gt;

&lt;h2 id=&#34;the-crossovers:4f5e1fa087d5cae149dabfbcf54f13c6&#34;&gt;The Crossovers&lt;/h2&gt;

&lt;p&gt;However, the story doesn&amp;rsquo;t stop here. In Swift, an &lt;code&gt;enum&lt;/code&gt;&amp;rsquo;s option can have
multiple values. If it happens to be the only option, then this
&lt;code&gt;enum&lt;/code&gt;effectively becomes a &lt;em&gt;product&lt;/em&gt; type:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// there are 6 * 6 = 36 potential values for Parters
enum Parters {
    case Value(wolf: DireWolf, person: StarkChild)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Incidentally, this makes &lt;code&gt;enum&lt;/code&gt; similar to &lt;code&gt;data&lt;/code&gt; in Haskell, where &lt;em&gt;product&lt;/em&gt;
and &lt;em&gt;sum&lt;/em&gt; types can be created with a unified construct â€“ &lt;code&gt;data&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In C and C++, &lt;code&gt;union&lt;/code&gt;s are the closest thing to &lt;em&gt;sum&lt;/em&gt; types. However, &lt;code&gt;union&lt;/code&gt;
is hardly used to combine arbitrary types due to its lack of associated
values. What do people do in need of &lt;em&gt;sum&lt;/em&gt; types? They make do with product
types. Here&amp;rsquo;s one way to achive that in Swift:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Actor.value can have only 6 + 6 = 12 potential values thanks to
// manual enforcement
class Actor {
    var child: StarkChild?
    var wolf: Direwolf?

    var value: Any {
        get {
            return child == nil ? wolf! : child!
        }
        set(newValue) {
            if newValue is StarkChild {
                child = (newValue as! StarkChild)
                wolf = nil
            }
            if newValue is Direwolf {
                wolf = (newValue as! Direwolf)
                child = nil
            }
        }
    }

    init(wolf: Direwolf) {
        self.wolf = wolf
    }
    init(child: StarkChild) {
        self.child = child
    }
    init() {
        fatalError(&amp;quot;must initialize with a child or a wolf&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;sâ€¦ ugly.&lt;/p&gt;

&lt;h2 id=&#34;recursion-types:4f5e1fa087d5cae149dabfbcf54f13c6&#34;&gt;Recursion Types&lt;/h2&gt;

&lt;p&gt;Besides &lt;em&gt;sum&lt;/em&gt; and &lt;em&gt;product&lt;/em&gt;, another common class of algebraic type is
recursion types. The interesting bit here is that Swift struggles to support
it. In WWDC 2015, it was announced that &lt;code&gt;enum&lt;/code&gt;s can be defined recursively in
Swift 2:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;enum Tree {
    case Empty
    indirect case Node(Tree, Tree)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As of this writing, Xcode 7 beta 3 has not delivered this feature yet.
Also, it&amp;rsquo;s a good bet that &lt;code&gt;indirect&lt;/code&gt; is not going to be available in tuple
aliases, such as:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;typealias Node = (indirect Node, indirect Node)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I hope this is on the Swift team&amp;rsquo;s (understandably) gigantic todo list ðŸ˜‰.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Dynamic Swift Framework Without Xcode</title>
      <link>http://dduan.net/post/2015/07/dynamic-swift-framework-without-xcode/</link>
      <pubDate>Sun, 05 Jul 2015 22:36:09 PDT</pubDate>
      
      <guid>http://dduan.net/post/2015/07/dynamic-swift-framework-without-xcode/</guid>
      <description>&lt;p&gt;I came up with this question recently:&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;en&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;Can we even use Frameworks with &lt;a href=&#34;https://twitter.com/hashtag/Swiftlang?src=hash&#34;&gt;#Swiftlang&lt;/a&gt; on Linux?&lt;/p&gt;&amp;mdash; Daniel Duan (@daniel_duan) &lt;a href=&#34;https://twitter.com/daniel_duan/status/617470929241706496&#34;&gt;July 4, 2015&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;And I&amp;rsquo;m going to give the answer in this post (spoiler alert: yes, sort of).&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the content of a framework created by Xcode:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/2015/07/just-framework-structure.png&#34; alt=&#34;Just Framework Structure&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;Some of the files, such as &lt;code&gt;Info.plist&lt;/code&gt;, are obviously construct of Xcode.
Play with &lt;code&gt;swiftc&lt;/code&gt; long enough, one would find that the &lt;code&gt;.swiftdoc&lt;/code&gt;s, the
&lt;code&gt;.swiftmodule&lt;/code&gt;s and the one binary file came from the Swift compiler.&lt;/p&gt;

&lt;p&gt;Instead of listing the relevant &lt;code&gt;swiftc&lt;/code&gt; command options, I&amp;rsquo;ve created a &lt;a href=&#34;https://github.com/dduan/Swift-Framework-Without-Xcode&#34;&gt;sample project&lt;/a&gt; to demonstrate how one can complie and link to frameworks so that they can be &lt;code&gt;import&lt;/code&gt;ed in the application code. The key ingredient for achieving it lies in &lt;em&gt;Makefile&lt;/em&gt;. In summary, &lt;code&gt;swiftc&lt;/code&gt; can do these for us:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;generate a binary as a library/framework&lt;/li&gt;
&lt;li&gt;emit a &lt;code&gt;.swiftmodule&lt;/code&gt; file, which Swift needs to understand that binary.&lt;/li&gt;
&lt;li&gt;assign a path the Swift runtime needs to locate this framework.&lt;/li&gt;
&lt;li&gt;compile source code that imports the framework, given that they exist in the paths relative to the app binary in step 3.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Based on these observations, it&amp;rsquo;s not hard to imagine more sophisticated build systems, such as IDEs and package/dependency management systems.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Let&#39;s Build A &#39;cat&#39; In Swift 2</title>
      <link>http://dduan.net/post/2015/07/lets-build-a-cat-in-swift-2/</link>
      <pubDate>Sat, 04 Jul 2015 20:56:19 PDT</pubDate>
      
      <guid>http://dduan.net/post/2015/07/lets-build-a-cat-in-swift-2/</guid>
      <description>&lt;p&gt;As a homework in one of the early college classes, I was asked to write unix
commands such as &lt;code&gt;cat&lt;/code&gt; in C. Let&amp;rsquo;s do that in Swift today! To make things
interesting, let&amp;rsquo;s pretend we are on Linux. That means no Xcode nor Foundation
can be used.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s hard to find a simpler unix program than &lt;code&gt;cat&lt;/code&gt;: It takes a list of file
names from the shell and write the content of each file to &lt;code&gt;stdout&lt;/code&gt;. When no
argument is given, it uses &lt;code&gt;stdin&lt;/code&gt; as the source of its output.&lt;/p&gt;

&lt;p&gt;Writing it in C is trivial. Swift has exellent support for leveraging C. But
to call even the standard C functions, we need to import them first.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;swiftc&lt;/code&gt; command can compile a pure Swift source file like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;swiftc cat.swift -o cat
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can add Objective-C bridging headers with the argument
&lt;code&gt;-import-objc-header&lt;/code&gt;.  But to import the standard C functions, we also need
to specify path to an SDK:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;swiftc -sdk $(xcrun --show-sdk-path --sdk macosx)\
       -import-objc-header bridge.h\
       cat.swift\
       -o cat
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Instead of typing/copying that command, save this &lt;code&gt;Makefile&lt;/code&gt; to the same
directory as &lt;code&gt;cat.swift&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SDKPATH = $(shell xcrun --show-sdk-path --sdk macosx)
CBRIDGEHEADER = bridge.h
TARGETS := cat

.PHONY : all $(TARGETS)

all: $(TARGETS)

$(TARGETS):
    swiftc -sdk $(SDKPATH) $@.swift -import-objc-header $(CBRIDGEHEADER) -o $@
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now &lt;code&gt;make cat&lt;/code&gt; should take care of the compilation.&lt;/p&gt;

&lt;p&gt;Since file I/O is the only concern, we&amp;rsquo;ll need C APIs from &lt;code&gt;stdio.h&lt;/code&gt;, so
&lt;code&gt;bridge.h&lt;/code&gt; is a one liner:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#import &amp;lt;stdio.h&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The standard C function for opening a file is &lt;code&gt;fopen&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FILE * fopen ( const char *filename, const char *mode );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hmmmm, how do we deal with all those pesky &amp;lsquo;*&amp;rsquo;s?&lt;/p&gt;

&lt;p&gt;To reference a certain C &lt;code&gt;Type&lt;/code&gt; in Swift, we can use &lt;code&gt;UnsafePointer&amp;lt;Type&amp;gt;&lt;/code&gt; or
&lt;code&gt;UnsafeMutablePointer&amp;lt;Type&amp;gt;&lt;/code&gt;. To make our lives easier, Swift &lt;code&gt;String&lt;/code&gt;s
automatically bridge to &lt;code&gt;const char *&lt;/code&gt;. In other words, we can treat the
signature of &lt;code&gt;fopen&lt;/code&gt; as if it&amp;rsquo;s the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func fopen( filename: String, mode: String ) -&amp;gt; UnsafeMutablePointer&amp;lt;FILE&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A character in C is represented by a byte in memory. Therefore Swift sees
a &lt;code&gt;char&lt;/code&gt; as of type &lt;code&gt;Int8&lt;/code&gt; (8-bit integer).  So a &lt;code&gt;char *&lt;/code&gt; would be referenced
as &lt;code&gt;UnsafeMutablePointer&amp;lt;Int8&amp;gt;&lt;/code&gt; in Swift. So &lt;code&gt;getline&lt;/code&gt;, a function from POSIX&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssize_t getline( char **lineptr, size_t *n, FILE *stream );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;would look like this in Swift:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func getline(
    inout lineptr: UnsafeMutablePointer&amp;lt;Int8&amp;gt;,
    inout n: UInt,
    stream: UnsafeMutablePointer&amp;lt;FILE&amp;gt;
) -&amp;gt; Int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It returns the number if characters it finds.&lt;/p&gt;

&lt;p&gt;We now can open a file, read and print its content line by line, and close it
with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func fclose(stream: UnsafeMutablePointer&amp;lt;FILE&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Repeat this on each file specified in &lt;code&gt;Process.arguments&lt;/code&gt;, or simply read from
&lt;code&gt;stdin&lt;/code&gt;, and we have a &lt;code&gt;cat&lt;/code&gt;! Here&amp;rsquo;s a screenshot of it displaying its own
code:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/2015/07/swift-cat.png&#34; alt=&#34;Swift cat&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;The code is also available in this &lt;a href=&#34;https://gist.github.com/dduan/f6d359019db8b0b55962&#34;&gt;gist&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>NeoVim, Swift and Make</title>
      <link>http://dduan.net/post/2015/04/neovim-swift-and-make/</link>
      <pubDate>Wed, 22 Apr 2015 11:46:17 PDT</pubDate>
      
      <guid>http://dduan.net/post/2015/04/neovim-swift-and-make/</guid>
      <description>&lt;p&gt;When it comes to Swift source code editing, nothing beats Xcode 6.3! That
includes Xcode 6.2, which drove me to good&amp;rsquo;O Vim for a while.&lt;/p&gt;

&lt;p&gt;Except it&amp;rsquo;s not the old Vim, I&amp;rsquo;m trying out &lt;a href=&#34;http://neovim.org&#34;&gt;NeoVim&lt;/a&gt;. The
most noticable difference in NeoVim compared to Vim is its recent
addition of a built-in terminal.&lt;/p&gt;

&lt;p&gt;With the help of syntax highlighting and a Makefile, working with Swift this
way turns out to be a fine alternative.&lt;/p&gt;

&lt;p&gt;(As a side benefit, I&amp;rsquo;m forced to use only local-context autocompletion. Now
I can actually spell out full UIKit APIs ðŸ˜‰.)&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a gif:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/2015/04/demo.gif&#34; alt=&#34;Make Swift NeoVim Demo&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;Some details are easy to miss. I pressed &lt;code&gt;,m&lt;/code&gt;, &lt;code&gt;,&lt;/code&gt; being my binding for
&lt;code&gt;&amp;lt;leader&amp;gt;&lt;/code&gt;. A terminal session launched with the &lt;code&gt;make&lt;/code&gt; command running. When
that&amp;rsquo;s done, I could press any key and the terminal pane was dismissed. Since
&lt;code&gt;test&lt;/code&gt; is the default target in my &lt;code&gt;Makefile&lt;/code&gt;, the test suit for my Swift
codes actually ran.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s how the shortcut is set in &lt;code&gt;.nvimrc&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if has(&#39;nvim&#39;)
    nnoremap &amp;lt;leader&amp;gt;m :rightbelow vertical split &amp;lt;bar&amp;gt; :term make&amp;lt;cr&amp;gt;
endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The makefile is pretty straightforword if you&amp;rsquo;ve worked with &lt;code&gt;xcodebuild&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;test :
    @xcodebuild test -project ProjectName.xcodeproj -scheme SchemeName -destination &#39;platform=iOS Simulator,name=iPhone 6&#39; | xcpretty

clean :
    @xcodebuild clean
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/supermarin/xcpretty&#34;&gt;xcpretty&lt;/a&gt; is a nifty script that
makes &lt;code&gt;xcodebuild&lt;/code&gt;s output much more readable.&lt;/p&gt;

&lt;p&gt;Happy vimming, Swifties :)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Swift Function Fun Facts</title>
      <link>http://dduan.net/post/2015/04/swift-function-fun-facts/</link>
      <pubDate>Sat, 18 Apr 2015 16:20:16 PDT</pubDate>
      
      <guid>http://dduan.net/post/2015/04/swift-function-fun-facts/</guid>
      <description>&lt;p&gt;You love Swift. You want to write a class that does HTTP, it might have methods like the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func get(URLString:String, params:[String:AnyObject], headers:[String:String])
func post(URLString:String, params:[String:AnyObject], headers:[String:String])
func put(URLString:String, params:[String:AnyObject], headers:[String:String])
// and more for HEAD, OPTIONS â€¦
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But you don&amp;rsquo;t want to force your user to supply all arguments each time. You know that Swift supports default arguments, so you added some. Take GET as an example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func get(URLString:String, params:[String:AnyObject]=[:], headers:[String:String]=[:])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now users can do things like&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;get(&amp;quot;http://github.com&amp;quot;)
get(&amp;quot;http://httpbin.org/get&amp;quot;, headers:[&amp;quot;Answer&amp;quot;:42])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s flexible! Woohoo!&lt;/p&gt;

&lt;p&gt;After you thought about implementing these, though, you realize that &lt;code&gt;HTTPMethod&lt;/code&gt; is merely a property on &lt;code&gt;NSURLRequest&lt;/code&gt;. In other words, all of the previous methods can share the same implementation. In honor of the DRY principle, you write a function that accepts the method as an arguments and the previous functions each forwards the arguments to this function:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func impl(method:String, URLString:String, params:[String:AnyObject], headers:[String:String]) { // â€¦ }

func get(URLString:String, params:[String:AnyObject]=[:], headers:[String:String]=[:])
    impl(&amp;quot;GET&amp;quot;, URLString:URLString, params:params, headers:headers)
}

func post(URLString:String, params:[String:AnyObject]=[:], headers:[String:String]=[:])
    impl(&amp;quot;POST&amp;quot;, URLString:URLString, params:params, headers:headers)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This seems like a sensible solution. Except that later you realize that there needs to be more parameters for each function, so in the end, each function looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func post(
    URLString              : String,
    params                 : [String:AnyObject]       = [:],
    json                   : [String:AnyObject]?      = nil,
    headers                : [String:AnyObject]       = [:],
    auth                   : (String,String)?         = nil,
    allowRedirects         : Bool                     = true,
    requestBody            : NSData?                  = nil,
    URLQuery               : String?                  = nil,
    asyncCompletionHandler : ((HTTPResult!) -&amp;gt; Void)? = nil
    ) -&amp;gt; HTTPResult {
    return impl(
        &amp;quot;POST&amp;quot;,
        URLString              : URLString,
        params                 : params,
        json                   : json,
        headers                : headers,
        auth                   : auth,
        data                   : requestBody,
        URLQuery               : URLQuery,
        redirects              : allowRedirects,
        asyncCompletionHandler : asyncCompletionHandler
    )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Remembering that your goal is to respect DRY, and there are now giant blocks of code that all look the same except that first argument to &lt;code&gt;impl()&lt;/code&gt;, you became determined to find a better alternative.&lt;/p&gt;

&lt;p&gt;Well, why not give currying a try? This example of currying with Swift comes to your mind:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func add(a:Int)(b:Int) -&amp;gt; Int { return a + b }
let add3 = add(3)
add3(b:2) // 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we apply this technique and treat &lt;code&gt;method&lt;/code&gt; in &lt;code&gt;impl()&lt;/code&gt; as &lt;code&gt;a&lt;/code&gt; in the example, we would get:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func impl(method:String)(URLString:String, params:[String:AnyObject], headers:[String:String], â€¦) { // â€¦ }
let get = impl(&amp;quot;GET&amp;quot;)
let post = impl(&amp;quot;POST&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;right?  However, you are forcing users to supply each argument again. To make things worse, the number of arguments is a lot larger.&lt;/p&gt;

&lt;p&gt;Hmm, but that&amp;rsquo;s a solved problem, just add default values to &lt;code&gt;impl()&lt;/code&gt;&amp;rsquo;s parameters:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func impl(method:String)(URLString:String, params:[String:AnyObject] = [:], headers:[String:String] = [:], â€¦) { // â€¦ }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ta-da! Wait a minute, Xcode now refuse to compile you code! &lt;code&gt;Default argument is only permitted for a non-curried function parameter&lt;/code&gt;, it saids.&lt;/p&gt;

&lt;p&gt;Stubborn as you are, you decide that perhaps the Swift team hasn&amp;rsquo;t got around to implementing this feature for curry syntax yet. Functions are first-class citizens! Surely if you return a function with default argumentsâ€¦?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func methodFactory(method:String) -&amp;gt; (params:[String:AnyObject] = [:], headers:[String:String] = [:], â€¦) -&amp;gt; Void {
    return {(params, headers, â€¦) in
        impl(method, params:params, headers:headers, â€¦)
    }
}

let get = methodFactory(&amp;quot;GET&amp;quot;)
let post = methodFactory(&amp;quot;POST&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Turns out, this manual form of currying only works when default arguments aren&amp;rsquo;t involved!&lt;/p&gt;

&lt;p&gt;Now, you hate Swift.&lt;/p&gt;

&lt;p&gt;(Hi HN, just to be clear, I don&amp;rsquo;t really hate Swift as in, uh, &lt;em&gt;hate&lt;/em&gt; Swift. Judgning from some comments, I might have failed to convey the lightheartedness that I felt writing this up. It&amp;rsquo;s really like saying to a friend &amp;ldquo;I hate you&amp;rdquo; after he/she pulls a prank on you.)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>My Xcode 6.2 And 6.3 Prediction</title>
      <link>http://dduan.net/post/2015/02/my-xcode-62-and-63-prediction/</link>
      <pubDate>Tue, 10 Feb 2015 02:09:50 PST</pubDate>
      
      <guid>http://dduan.net/post/2015/02/my-xcode-62-and-63-prediction/</guid>
      <description>&lt;p&gt;We have a situation here: three versions of Xcode are available to devleopers as of this writing.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Xcode 6.1.1&lt;/li&gt;
&lt;li&gt;Xcode 6.2 beta&lt;/li&gt;
&lt;li&gt;Xcode 6.3 beta&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;6.2 is released with the purpose of making WatchKit availale.&lt;/p&gt;

&lt;p&gt;6.3, so far, has been focused on Swift 1.2 and new Objective-C features, and a
few non-language related features.&lt;/p&gt;

&lt;p&gt;The fact that there are two betas indicates to me each will be followed up by
an official release. So how?&lt;/p&gt;

&lt;p&gt;My guess: there will be an official Xcode 6.2 release after ï£¿Watch release. It doesn&amp;rsquo;t make much sense to skip a minor version.&lt;/p&gt;

&lt;p&gt;Then things get interesting. ï£¿Watch is coming out in April. Shortly after that, we&amp;rsquo;ll have WWDC. Usually, WWDC comes with major Xcode beta release. So &amp;hellip; what happens to version 6.3?&lt;/p&gt;

&lt;p&gt;My guess: either we&amp;rsquo;ll never get Xcode 6.3, or we won&amp;rsquo;t get Xcode 7 this year.&lt;/p&gt;

&lt;p&gt;The former make sense in the context that &lt;a href=&#34;http://9to5mac.com/2015/02/09/apples-ios-9-to-have-huge-stability-and-optimization-focus-after-years-of-feature-additions/&#34;&gt;Apple Is Focused on Stablity&lt;/a&gt;. Xcode needs some love on that front, let&amp;rsquo;s face it!&lt;/p&gt;

&lt;p&gt;On the other hand, no harm would be done if Apple market 6.3 as version 7 come WWDC. Afterall, Swift 1.2 is significant enough to justify a major version.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Build And Run iOS Apps In Commmand Line</title>
      <link>http://dduan.net/post/2015/02/build-and-run-ios-apps-in-commmand-line/</link>
      <pubDate>Sat, 07 Feb 2015 20:35:02 PST</pubDate>
      
      <guid>http://dduan.net/post/2015/02/build-and-run-ios-apps-in-commmand-line/</guid>
      <description>&lt;p&gt;Xcode is slow. Enough said. What&amp;rsquo;s worse, sometimes I find myself
relying too much on auto-completion with Cocoa Touch, a blessing and a curse!&lt;/p&gt;

&lt;p&gt;So I searched for an alternative workflow in command line. The result was
rather confusing: there are posts about using &lt;code&gt;xctool&lt;/code&gt; or &lt;code&gt;xcodebuild&lt;/code&gt; to
build Xcode targets, using &lt;code&gt;ios-sim&lt;/code&gt;, &lt;code&gt;simctl&lt;/code&gt;  or &lt;code&gt;instruments&lt;/code&gt; to manage and
manage or launch simulators. Most of the information is out of date.&lt;/p&gt;

&lt;p&gt;Eventually though, I was able to piece together an answer for my needs.
That is, given an iOS project set up with Xcode 6, I want to&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;build a target.&lt;/li&gt;
&lt;li&gt;launch a iOS simulator.&lt;/li&gt;
&lt;li&gt;install the built .app bundle to the launched simulator.&lt;/li&gt;
&lt;li&gt;run the installed app.&lt;/li&gt;
&lt;li&gt;uninstall the app from the simulator.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;All in command line, with Xcode &lt;em&gt;closed&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Before we proceed to the steps, you need to gather a few pieces of information:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;the Xcode build scheme of your choice (e.g. &amp;ldquo;AwesomeApp&amp;rdquo;).&lt;/li&gt;
&lt;li&gt;your app bundle ID (e.g. &amp;ldquo;com.awesome.app&amp;rdquo;).&lt;/li&gt;
&lt;li&gt;name of an existing simulator (e.g. &amp;ldquo;iPhone 6 Plus&amp;rdquo;). If you don&amp;rsquo;t want to
look it up in Xcode GUI, look for it in output of command &lt;code&gt;xcrun simctl
list&lt;/code&gt; .&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Ready? Here we go.&lt;/p&gt;

&lt;p&gt;(These commands should be run in the project folder).&lt;/p&gt;

&lt;p&gt;Build the target:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xcodebuild -scheme AwesomeApp -destination &#39;platform=iphonesimulator,name=iPhone 6 Plus&#39; -derivedDataPath build
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Launch the simulator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xcrun instruments -w &#39;iPhone 6 Plus&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Install the bundle (after simulator is launched and target is built with
previous commands):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xcrun simctl install booted build/Build/Products/Debug-iphonesimulator/AwesomeApp.app
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Launch the app in simulator (after it&amp;rsquo;s installed with the previous command):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xcrun simctl launch booted com.awesome.app
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Uninstall the bundle:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xcrun simctl uninstall booted com.awesome.app
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Quite a few parameters needs to be added for the build step if you have
a comlex project. Please RTFMs. Write some script to automate the steps, if
are a lazy typiest like me.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>tableView:didSelectRowAtIndexPath: In Two Lines</title>
      <link>http://dduan.net/post/2014/05/tableview58didselectrowatindexpath58-in-two-lines/</link>
      <pubDate>Sat, 03 May 2014 13:42:00 -0600</pubDate>
      
      <guid>http://dduan.net/post/2014/05/tableview58didselectrowatindexpath58-in-two-lines/</guid>
      <description>&lt;p&gt;You have a &lt;code&gt;UITableViewController&lt;/code&gt; with a couple of static cells, you want to
invoke some code for each cell in the delegate. Here&amp;rsquo;s a quick way to do it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    - (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath
    {

        SEL action = (SEL[]){@selector(method1), @selector(method2)}[indexPath.row];
        ((void (*)(id, SEL))[self methodForSelector: action])(self, action);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s got everything you love about C and Objective-C: array literals, function
pointers, casting, selectors and something called &lt;a href=&#34;http://www.cocoawithlove.com/2008/02/imp-of-current-method.html&#34;&gt;IMPs&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This piece of code maps selected cells to methods by putting methods by
indexing selectors in a C array.&lt;/p&gt;

&lt;p&gt;Why all the fuss on the second line? wouldn&amp;rsquo;t a simple &lt;code&gt;performSelector:&lt;/code&gt;
work? The short answer is: to show the compiler that we are responsible
adults. You can read more about it &lt;a href=&#34;SO Answer&#34;&gt;here&lt;/a&gt;;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>One Weird Trick To Make Vim Go Faster On Your Mac</title>
      <link>http://dduan.net/post/2014/05/one-weird-trick-to-make-vim-go-faster-on-your-mac/</link>
      <pubDate>Fri, 02 May 2014 10:25:00 -0600</pubDate>
      
      <guid>http://dduan.net/post/2014/05/one-weird-trick-to-make-vim-go-faster-on-your-mac/</guid>
      <description>&lt;p&gt;I noticed something strange today.&lt;/p&gt;

&lt;p&gt;While playing with Ubuntu on a VirtualBox hosted by OS X Mavericks, Vim
&lt;em&gt;seems&lt;/em&gt; much faster than it being in iTerms2. How could that be? So I took the
following steps to test things out:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Installed exact configurations with Vundle on the VM.&lt;/li&gt;
&lt;li&gt;Vim in Terminal.app&lt;/li&gt;
&lt;li&gt;MacVim with GUI.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Nope, Vim is still more responsive on Ubuntu. In fact, text input seem more
responsive on this VM than the host OS in general! I thought I came to the
light switching to OS X after using Linux as desktop for years, and now this?
&lt;em&gt;&lt;a href=&#34;http://developer.android.com/reference/android/util/Log.html#wtf(java.lang.String,%20java.lang.Throwable)&#34;&gt;WTF&lt;/a&gt;?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Defeat and confused, I went to the Internet, and found &lt;a href=&#34;http://stackoverflow.com/questions/4489885/how-can-i-increase-cursor-speed-in-terminal&#34;&gt;something close to an
answer&lt;/a&gt;. Under &lt;em&gt;System Preferences-Keyboard&lt;/em&gt;, drag the two slide
widget (&amp;ldquo;Key Repeat&amp;rdquo; and &amp;ldquo;Deley Until Repeat&amp;rdquo;) to the right most. Suddenly,
Vim become faster!&lt;/p&gt;

&lt;p&gt;Turns out, key repeating is very important for Vim users.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Installing PyQt5 with Python 3 On OS X</title>
      <link>http://dduan.net/post/2014/04/installing-pyqt5-with-python-3-on-os-x/</link>
      <pubDate>Wed, 23 Apr 2014 10:36:00 -0600</pubDate>
      
      <guid>http://dduan.net/post/2014/04/installing-pyqt5-with-python-3-on-os-x/</guid>
      <description>&lt;p&gt;Today I installed PyQt5 on OS X 10.9. Turns out, it&amp;rsquo;s not as straight-forward
as one would think.&lt;/p&gt;

&lt;p&gt;Using &lt;code&gt;homebrew&lt;/code&gt; will &lt;strong&gt;not&lt;/strong&gt; work:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    brew install PyQt5 --with-python3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is because of &lt;a href=&#34;https://github.com/Homebrew/homebrew/issues/25735&#34;&gt;an unfortunate choice&lt;/a&gt; made by the
homebrew maintainer regarding Python 3.&lt;/p&gt;

&lt;p&gt;So installing from &lt;a href=&#34;http://pyqt.sourceforge.net/Docs/PyQt5/installation.html&#34;&gt;source&lt;/a&gt; is the way to go. Following the
installing instruction, you would download and install &lt;a href=&#34;http://pyqt.sourceforge.net/Docs/sip4/installation.html&#34;&gt;sip&lt;/a&gt;
first, the install &lt;a href=&#34;http://pyqt.sourceforge.net/Docs/PyQt5/installation.html&#34;&gt;PyQt5&lt;/a&gt; itself.&lt;/p&gt;

&lt;p&gt;Except that&amp;rsquo;s not enough. When you run &lt;code&gt;python configure.py&lt;/code&gt;, you see this
error:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    error: Use the --qmake argument to explicitly specify a working Qt
    qmake.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s pretty self-explanatory. &lt;code&gt;qmake&lt;/code&gt;, the build tool for qt is needed here.
Install qt5 with homebrew and proceed:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    brew install qt5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Afterwards, you should be able to import &lt;code&gt;PyQt5&lt;/code&gt; in a Python 3 REPL.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Generating Xcode Build Number From Git</title>
      <link>http://dduan.net/post/2013/09/generating-xcode-build-number-from-git/</link>
      <pubDate>Sun, 29 Sep 2013 15:50:50 -0600</pubDate>
      
      <guid>http://dduan.net/post/2013/09/generating-xcode-build-number-from-git/</guid>
      <description>&lt;p&gt;The build version number in an Xcode project (CFBundleVersion in Info.plist)
must be a monotonically increasing string for each archive submitted to the
App Store. Neglection of this requirement will result in an error during the
binary upload. Some automation will help avoiding this issue.&lt;/p&gt;

&lt;p&gt;First, we want to generate this version number from our version (&lt;em&gt;duh&lt;/em&gt;)
control system (VCS) each time our target gets built. My VCS of choice is Git,
users of other systems just need to get a increasing number from their code
history. On a *nix system, this command will count the number of commits on
&amp;lsquo;develop&amp;rsquo; branch up until HEAD:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    git rev-list develop | wc -l
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a very good candidate for our build number, for longer history
generally correlates to later builds.&lt;/p&gt;

&lt;p&gt;Next, we make Xcode automatically run this command and use its result as the
build number.&lt;/p&gt;

&lt;p&gt;Go to project navigator, select your build target under the project icon,
click &lt;em&gt;Build Phases&lt;/em&gt;, select &lt;em&gt;Editorâ†’Add Build Phaseâ†’Add Run Script Build
Phase&lt;/em&gt; in the menu. Remove the content in editor of the new &lt;em&gt;Run Script&lt;/em&gt;
phase and replace it with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;revnum=`git rev-list develop | wc -l`
echo &amp;quot;#define BUILD_NUMBER $revnum&amp;quot; &amp;gt; InfoPlist.h
touch InfoPlist.h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Go to build settings, change value of &lt;em&gt;Preprocess Info.plist File&lt;/em&gt; to &amp;ldquo;YES&amp;rdquo;.
Add &amp;ldquo;InfoPlist.h&amp;rdquo; to &lt;em&gt;Info.plist Preprocessor Prefix Fileâ†’release&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;We ask Xcode to run our command and save its result as a &amp;ldquo;#define&amp;rdquo; in a header
file when it builds the project. This is done so that we can replace the
&amp;ldquo;hardcoded&amp;rdquo; build number with the name of the constant:&lt;/p&gt;

&lt;p&gt;Open Info.plist, Double click the value of &lt;em&gt;Bundle Version&lt;/em&gt; and replace it with&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;BUILD_NUMBER
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There&amp;rsquo;s only one issue left: &lt;code&gt;BUILD_NUMBER&lt;/code&gt; is now saved in &lt;em&gt;InfoPlist.h&lt;/em&gt;. Its
value comes from our commit history. So we want to exclude this piece of
information as part of our commit history (I&amp;rsquo;ll leave the reason as an exercise
for the reader). Ignore this file by adding &amp;ldquo;InfoPlist.h&amp;rdquo; to &lt;em&gt;.gitignore&lt;/em&gt; (or
that of your other VCS).&lt;/p&gt;

&lt;p&gt;To recap, when you build the project now, Xcode will find out how many commits
are in the history, define it in a header file as &lt;code&gt;BUILD_NUMBER&lt;/code&gt;, which gets
used as the build number. As long as you keep with with version control, the
build number problem goes away.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Sencha Touch 2 and PhoneGap integration</title>
      <link>http://dduan.net/post/2013/05/sencha-touch-2-and-phonegap-integration/</link>
      <pubDate>Tue, 28 May 2013 15:24:30 -0600</pubDate>
      
      <guid>http://dduan.net/post/2013/05/sencha-touch-2-and-phonegap-integration/</guid>
      <description>&lt;p&gt;As one of my pet Sencha Touch project gets close to finish, I started
looking into distribute it as native apps with Phonegap/Cordova.&lt;/p&gt;

&lt;p&gt;One of the concerns in do so is the &amp;lsquo;deviceready&amp;rsquo; event provided by Phonegap,
according to the documentation:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This is a very important event that every Cordova application should use.&lt;br /&gt;
&amp;hellip;&lt;/p&gt;

&lt;p&gt;The Cordova deviceready event fires once Cordova has fully loaded.
After the device has fired, you can safely make calls to Cordova function.&lt;/p&gt;

&lt;p&gt;Typically, you will want to attach an event listener with
document.addEventListener once the HTML document&amp;rsquo;s DOM has loaded.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In particular, the nice Sencha Touch microloader complicate the matter by
being the sole Javascript file that&amp;rsquo;s supposed to be included in &lt;code&gt;index.html&lt;/code&gt;
and is in charge of starting the actual code of our apps. Yet we need the
starting point of the code be a response to the &lt;code&gt;deviceready&lt;/code&gt; event.&lt;/p&gt;

&lt;p&gt;After some googling, I found that most information on this matter is either
inaccurate, incomplete or outdated, that is until I found &lt;a href=&#34;http://stackoverflow.com/a/10457158/243798&#34;&gt;this answer&lt;/a&gt; by
&lt;a href=&#34;http://dougan.me&#34;&gt;Robert Dougan&lt;/a&gt; on StackOverflow:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Sencha Touch 2 will listen to that event and call your onReady/launch methods
- therefore if you try listening to them in the launch method,
it has already been fired.&lt;/p&gt;

&lt;p&gt;Just put your logic inside the launch method in your application.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;To verify this claim, I dug into &lt;code&gt;sencha-touch-debug.js&lt;/code&gt; distributed with
Sencha Touch 2.2 and found the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (Ext.browser.is.PhoneGap &amp;amp;&amp;amp; !Ext.os.is.Desktop) {
    if (!Ext.readyListenerAttached) {
        Ext.readyListenerAttached = true;
        document.addEventListener(&#39;deviceready&#39;, triggerFn, false);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It appears that the &lt;code&gt;deviceready&lt;/code&gt; event is taken into account here as long as
&lt;code&gt;Ext.browser.is.PhoneGap&lt;/code&gt; is true in a mobile browser envronment, which, in the
same source code, means:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (typeof window.PhoneGap != &#39;undefined&#39; ||
    typeof window.Cordova != &#39;undefined&#39;  ||
    typeof window.cordova != &#39;undefined&#39;) {
    isWebView = true;
    this.setFlag(&#39;PhoneGap&#39;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, the global variable PhoneGap, cordova or Cordova needs to be defined to
satisfy Sencha Touch 2&amp;rsquo;s expectation of PhoneGap environment. Those globals
are defined in the &lt;code&gt;cordova-x.y.x.js&lt;/code&gt; file included in the PhoneGap/Cordova
project files.&lt;/p&gt;

&lt;p&gt;So what needs to be done for the integration is simple (if not clear):&lt;/p&gt;

&lt;p&gt;include &lt;code&gt;cordova-x.y.x.js&lt;/code&gt; in the js section of &lt;code&gt;app.json&lt;/code&gt; project file so that
the microloader knows to load it up early:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;js&amp;quot;: [
    {
        &amp;quot;path&amp;quot;: &amp;quot;path/to/cordova-x.y.z.js&amp;quot;,
    },
    {
        &amp;quot;path&amp;quot;: &amp;quot;touch/sencha-touch.js&amp;quot;,
        &amp;quot;x-bootstrap&amp;quot;: true
    },
    {
        &amp;quot;path&amp;quot;: &amp;quot;app.js&amp;quot;,
        &amp;quot;bundle&amp;quot;: true, 
        &amp;quot;update&amp;quot;: &amp;quot;delta&amp;quot;
    }
],
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Run &lt;code&gt;sencha app build package&lt;/code&gt; and drop the files it produces to the &lt;code&gt;www&lt;/code&gt;
folder in the PhoneGap project.&lt;/p&gt;

&lt;p&gt;Compile, ship.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Sencha Touch Workflow with GNU Make and Tmux</title>
      <link>http://dduan.net/post/2013/05/sencha-touch-workflow-with-gnu-make-and-tmux/</link>
      <pubDate>Mon, 27 May 2013 15:00:00 -0600</pubDate>
      
      <guid>http://dduan.net/post/2013/05/sencha-touch-workflow-with-gnu-make-and-tmux/</guid>
      <description>&lt;p&gt;I throw this Makefile to the root directory of my Sencha Touch 2 projects for
workflow automation.&lt;/p&gt;

&lt;p&gt;Assuming you write in CoffeeScript and run Tmux in a terminal:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;make develop&lt;/code&gt; will put &lt;code&gt;compass&lt;/code&gt; and &lt;code&gt;coffee&lt;/code&gt; to watch mode, in addition to
spawning a local web server with Python 3. The three commands will run in three
separate Tmux panes.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;make watch&lt;/code&gt; does the same thing sans the server spawning.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;make&lt;/code&gt; simply compile coffee script files and sass files.&lt;/p&gt;

&lt;p&gt;You can figure out the granular commands with some minimal knowledge of GNU
Make.&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/DaNmarner/5659003.js&#34;&gt;&lt;/script&gt;
</description>
    </item>
    
  </channel>
</rss>